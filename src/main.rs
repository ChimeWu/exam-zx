///对所有权系统的理解
/// 1. 所有权规则
/// - Rust 中的每一个值都有一个被称为其所有者的变量。
/// - 值在任一时刻有且只有一个所有者。
/// - 当所有者（变量）离开作用域，这个值将被丢弃。
/// 2. 移动语义与Copy trait
/// rust默认情况下执行移动语义，移动发生的主要场景有：
/// - 将一个值赋值给另一个变量
/// - 将一个值作为参数传递给函数，或者从函数中返回值
/// - 非引用型的模式匹配
/// - 闭包的捕获
/// 移动的“效果”是将原有变量的值的所有权转移给新变量，原有变量不再拥有这个值，再次访问原有变量会报错。
/// move语义的目的是通过简单的规则来保证所有权规则2的正确性，以及降低规则3的实现难度
/// 同时可以避免默认的深拷贝带来的高开销。
/// 但是如果任何值在都需要遵守此规则，就会导致诸多不便，而储存在栈上的较简单的数据，如整数、浮点数、布尔值、字符等
/// 它们的内存释放会在函数调用结束后由退栈操作完成，不会造成内存泄漏，让它们实现移动语义显得多余。
/// 因此为这些数据类型实现了Copy trait，当一个值实现了Copy trait时，它的所有权不会在本该被移动时移动，而是会被复制。
/// 3. 与内存管理的联系
/// 内存管理的一个难题在于如何正确处理堆内存的释放，rust通过所有权系统，为每一个值都分配了一个“直接管理者”，即所有者。
/// 当发生移动时，所有者发生改变，但总是会有对应的所有者存在，有了所有者，就可以保证内存的正确释放。
/// 在较一般的情况下，rust的所有权系统会强制使程序中拥有资源的对象之间，呈现一种树形的关系，通过Drop的层层调用，可以大大简化内存管理的复杂度。
/// 4. 借用规则与生命周期
/// - 任何引用的生命周期必须至少不超过其引用的数据的生命周期。
/// - 同一时间只能有一个可变引用或任意数量的不可变引用。
/// 生命周期实际上是类型的一部分，并且生命周期的判定遵循继承规则。在大部分情况下，rust可以自动推导出生命周期，但是在一些情况下，需要手动指定生命周期。
/// 生命周期参数一般用来描述不同对象之间的生命周期的关系，而不是生命周期的具体长度。
/// 5. 借用检查推迟
/// 可以使用RefCell来将借用检查推迟到运行时
use exam_zx::myvec;

fn main() {
    let v = myvec![1, 2, 3, 4, 5];
    println!("{:?}", v);
}
